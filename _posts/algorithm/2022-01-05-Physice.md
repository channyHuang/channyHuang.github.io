<head>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber: "all" } } });
    </script>

    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {
             inlineMath: [ ['$','$'],["$$","$$"], ["\\(","\\)"] ],
             processEscapes: true
           }
         });
    </script>

    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
    </script>
</head>

---
layout: default
title: Physics.md
categories:
- Game
tags:
- Game
---
//Description: Physics in game, 游戏中使用到的物理笔记

//Create Date: 2022-01-05 20:32:39

//Author: channy

[toc]

# 概述 
游戏中使用到的物理笔记

# Convex Decomposition 凸分解
* Approximate Convex Decomposition (ACD)
* HACD
* VHACD

# Collision 碰撞算法
![Collision Detection](./imageFormat/CD.jpg)
broad-phase和narrow-phase两个步骤
> broad-phase 粗略计算，产生碰撞体pair; Spatial Hashing/BVH  
> narrow-phase 精确计算，得到各自的穿透点，对所有pair; DCD/CCD

## Discrete Collision Detection (DCD, 离散碰撞检测)

## Bounding Volume Hierarchies(BVH, 层次包围体技术)
Bounding Volume, 即BV (AABB, OBB, Bounding Sphere, Convex Hull ...)

**目标**   
将所有包围体分层逐次地再次包围，建立树形结构

**步骤**  
* 计算场景中每一个图元的BV包围盒、质心（一般取包围盒的中心）并存储到数组中。
* 根据不同的划分策略构建树状索引结构。
* 将得到二叉树转化更加紧凑的表示形式（无指针，内存连续）。

**说明及改进**  
构建过程中最重要的问题就是如何对图元进行划分  
* 树尽量平衡
* 各节点包围盒尽可能不重叠

基于莫顿码（Morton code）的并行化BVH: LBVHs（Linear bounding volume hierarchies）和HLBVH（hierarchical linear bounding volume hierarchy）

首先将场景中的图元按照其所处的位置将其分成若干簇（clusters），对于每一个簇，并行地构建子树，最后将每一颗子看成一个单一节点完成整棵树的构建。LBVHs的核心在于将BVH的构建转换为一个排序问题。LBVHs利用莫顿码来对多维度的空间数据进行排序。

## Surface Area Heuristic (SAH, 表面积启发)
**目标**  
在构建BVH树时插入节点，提升“各节点包围盒尽可能不重叠”。通过对求交代价和遍历代价进行评估，给出了每一种划分的代价

traversal cost 和 Hit probability

**步骤**  
节点 C 中存在 n 个物体，设每个物体求交代价traversal cost = t(i)，则不划分情况下求交总代价为： $\sum t(i) = t(1) + t(2) + ... + t(n)$

如果这些物体划分为2组，这两组物体分别处于它们的包围盒A和B中。设光线击中它们的概率hit probability = p(A) 和 p(B)，（包围盒 A 和 B 之间存在重叠，且不一定会填满其父节点的包围体）

$$ c(A, B) = p(A) \sum t(i) i \in A + p(B) \sum t(i) i \in B + t_trav $$

其中t_trav表示遍历BVH树的代价

一般情况下，对所有图元的求交代价相同，即t(i)相同，且t(i) > t_trav。则可简化t(i) = 1, t_trav = 0.125, A和B中分别有a和b个图元

$$ c(A, B) = p(A) a + p(B) b + 0.125 $$

光线击中包围盒的概率可以根据包围体的表面积来估计。即在父节点的包围体C中，A和B的表面积越大它们被击中的概率也就越大。记S为表面积，则

$$ c(A, B) = S(A) / S(C) * a + S(B) / S(C) * b + 0.125 $$

在实现的时候，相比于计算可能划分的代价然后寻找代价最小的划分，一种更好的办法是将节点 C 所包围的空间沿着跨度最长的那个坐标轴的方向将空间均等的划分为若干个桶（Buckets），划分只会出现在桶与桶之间的位置上。若桶的个数为 n 则只会有 n - 1 种划分的可能。

遍历 C 中所有的图元，统计每一个桶中图元的个数以及每一个桶的包围盒，就能计算每一种划分的代价

**说明及改进**  
> 场景中的图元在计算划分代价（cost）时被重复遍历。  
> 整个构建过程是自顶向下的（top-down），难以并行化。

## Separating Axis Theorem(SAT 分离轴定理)
**目标**

**原理**  
两个凸多边形不相交,当且仅当必然存在一条直线,两个凸多边形在这条直线上的投影不相交

两个凸多边形相交,则在所有直线上的投影都是相交的. 对于凸多面体也是一样的,只是投影在面上.

**步骤**  
对于两个多边形求相交,取其中一个多边形,遍历所有的边. 对于每条边, 顶点表示为 a 和 b ,向外的法线表示为 n . 然后判断另外一个多边形上的点是否都在这条边的外面,设点为 v ,求 (v-a).dot(n) 的值,根据值的符号,就可以判断出点在边的内侧或者外侧. 如果存在某条边,使得另外一个多边形上所有点都在外侧,即认为两个多边形不相交.

分别遍历两个多边形,找到所有计算出的 (v-a).dot(n) 值的最小值,还可以算出两个多边形相交的穿透深度.

对于多面体,原理是一样的,只是把边换成了面.

**说明及改进**  
只能适用于多边形/多面体,不能直接适用圆形/球形的物体.

**应用**  
box2d中多边形之间的碰撞通过SAT算法来实现.

## Gilbert-Johnson-Keerthi (GJK)
[GJK](http://www.dtecta.com/papers/jgt98convex.pdf)  
**目标**  
计算凸多面体之间最小距离 (A与(反射)B的闵可夫斯基(Minkowski)和)
$$ A - B = {x - y : x \in A, y \in B $$

**步骤**  
* 移动B的参考点到原点，然后反射B （如果原点在A - B内部，那么A和B就会重叠）
* 用B的参考点扫过A的表面
* 得到 A-B
* 原点到 A-B 的最小距离 d 即为所求

![GJK-d](./imageFormat/GJK-d.jpg)

* 对于 A-B，任选一个三角形，计算该三角形的最小距离
* 最近的顶点替换在这个投影上距离最远的三角形顶点
* 顶点被投影到从原点到上一步最近点的直线上
* 直到投影点和最近点重合，完成迭代  

**说明及改进**  
该算法从多面体中的任意一个单纯形开始。 一个单纯形在各个维度上是最简单的几何体，所以它在二维上是一个三角形，在三维上是一个四面体。对于两个多面体，算法在有限的步长内结束。 

采用增量计算和缓存等技术可以提高算法的性能。

**应用**  
chipmonk,bullet,physx中的碰撞都是通过GJK实现,box2d的CCD和部分碰撞检测也是通过GJK实现的,GJK是物理引擎中计算碰撞的主流方案

## Expanding Polytope Algorithm(EPA)  
**目标**  
GJK算出了当两个物体不相交时的最近距离.当两个几何体相交时,GJK算法会终止退出.

当GJK的算法退出后,我们在GJK得到的单纯形的基础上使用EPA算法,就可以算出两个几何体的穿透深度.

**步骤**  
* 获得与原点距离最短的边，记对应的闵可夫斯基差为 M1,M2 。求出与这条边垂直、且 背离原点 的向量。
* 计算得到的闵可夫斯基差 M3
* 若 $|M1 - M3| + |M2 - M3| < \epson $ ，退出迭代
* 若 M3 不属于在方向上找到的点，退出迭代
* 若 M1 == M3 或 M2 == M3，于已有单纯形发生重复，退出迭代

**说明及改进**  
只适用于凸多边形

## Minkowski Portal Refinement (MPR, 闵可夫斯基入口简化)
**目标**  
GJK + EPA 可以通过定制不同的 support 函数，轻松实现 椭圆 之间或 封闭凸曲线 构成的图形之间的碰撞计算，从而泛化物体碰撞。

入口（Portal）选择不当将会得到不恰当的结果，此时算法退化为 EPA

## Continuous Collision Detection(CCD, 连续碰撞检测)

### Time Of Impact (TOI)
* 扫掠法 (Sweep)
* 推测法 (Speculative)
* 保守步进法 (Conservative Advancement)
* 双边步进法 (Bilateral Advancement)
* 包围球近似 (Bounding Sphere Approximation)
* 光线投射 (Raycast)
* 解析解 (Analytical Solution)
* ……

# 3d拾取算法
1. 几何思路：通过连接摄像机和屏幕坐标生成射线，然后与场景中的物体做相交判断。
1. 渲染思路：对渲染的每个物体给予编号，将编号转换成颜色，然后通过拾取framebuffer的颜色来判断拾取到了哪个物体。

# Graham Scan 凸包
**目标**  
计算点集的凸包

**步骤**  
从点集中先找出一个最左下方的点，以这个点为极点，将所有点根据与这个点的极角排序，并且同时使用一个栈结构维护凸包上的点

按照极角序依次将点与栈顶的两个点拐向判断：若右拐，则将当前点加入栈中；否则，将栈顶的点弹出。当遍历完点集后，还在栈中的点就是凸包上的点，而且依次出栈可以得到从起点开始顺时针旋转的所有凸包上的点。

# Inverse Kinematics 逆向运动学
## 手臂顺向运动学 Forward Kinematics (FK)
## 手臂逆向运动学 Inverse Kinematics(IK)
已知末端位置，反算手臂各个关节的角度。

# Bullet3 代码基本结构

按windows + vs的解决方案分类
## demo类
1. App_BasicExample 创建基本的场景
1. App_ExampleBrowser 聚集了bullets的多个example
1. App_HelloBulletRobotics 文字输出robot的位置
1. App_HelloWorld 创建基本的场景并文字输出各物体位置
1. App_obj2sdf 文件格式转换obj->sdf
1. App_PhysicsServer_ShareMemory/App_PhysicsServer_ShareMemory_GUI 服务器端
1. App_RobotSimulator/App_RobotSimulator_NoGUI 四足机器人Minitaur
1. App_TwoJoint 
1. AppBaseExampleGui 基本的opengl显示及外设处理，创建了5*5*5个方块自由落体

### Bullet3 中的demo
ExampleEntries.cpp 中可以查看每个demo的入口函数

* App_ExampleBrowser
	* BasicExample 自由落体，碰撞检测
	* RollingFrictionDemo 滚动，摩擦系数
	* ConstraintDemo 各类约束，约束求解
	* Motorized Hinge+TestHingeTorque 铰链HingeConstraint+扭矩btGeneric6DofSpring2Constraint

## 单元测试类
Test_XXX 

## 功能类
1. Bullet3Collision/BulletCollision 碰撞相关
1. BulletSoftBody 软件物理
1. BulletRobotics/BulletRoboticsGUI 机器人控制，对应于demo中的App_RobotSimulator
1. Bullet3Dynamics/BulletDynamics 约束相关

1. Bullet3OpenCL_clew opencl多线程
1. clsocket 网络连接socket
1. BussIK 数学相关，Jacobian分解等 
1. BulletWorldImporter/BulletXmlWorldImporter 文件导入
1. Bullet3Common/Bullet3Geometry/LinearMath/OpenGLWindow/pybullet 数学、渲染、python相关
1. gwen 界面控件，GWEN-a gui library
1. ConvexDecomposition/GIMPACTUtils 凸分解
1. HACD 凸分解的HACD库，有改进版VHACD

## 其它类
1. Bullet2开头或是与Bullet3XXX相比少一个3的项目，为老Bullet2的代码，如BulletCollision、BulletDynamics等

按文件夹分  
* bullet3  
	* examples  
		* BasicDemo 
	* Extras
		* BulletRobotics  
		* HACD 凸包分解
	* src
		* Bullet3Collision 
		* Bullet3Dynamics
			* ConstraintSolver 求解器

## 陀螺力矩的计算原理。

　　根据欧拉方程很容易得到$\Delta\omega=\omega_2-\omega_1=\Delta tI^{-1}(T-\omega_1 \times I\omega_1)$，其中$\omega_1$是前一步的角速度、$\omega_2$是下一步的角速度。但是直接使用该公式迭代计算结果很容易发散。

## Bullet3 中的场景 World
* btCollisionWorld  
	* addCollisionObject 添加物体到场景  
	* performDiscreteCollisionDetection  
		* updateAabbs  
		* computeOverlappingPairs 检测碰撞对 (broad phase)  
		* dispatchAllCollisionPairs (遍历pairs计算精确碰撞, btDispatcher)  

* btCollisionDispatcher  
	* defaultNearCallback (narrow phase)

以 btDiscreteDynamicsWorld 为例，在构造函数中创建 Solver
* btCollisionWorld > btDynamicsWorld -> btDiscreteDynamicsWorld -> btMultiBodyDynamicsWorld -> btDeformableMultiBodyDynamicsWorld  
	* stepSimulation 类似于tick
		* internalSingleStepSimulation
			* predictUnconstraintMotion 计算物体在非约束条件下的运动  
			* predictMotion (btDeformableBodySolver)  
			* performDiscreteCollisionDetection (btCollisionWorld, 碰撞检测)  
			* solveConstraints 约束求解，其中 Solver 的 prepareSolve 和 allSolved 并没有具体实现
			* integrateTransforms 位移积分 

在 btMultiBodyDynamicsWorld 中
* solveConstraints
	* solveInternalConstraints (btDiscreteDynamicsWorld省略)
		* processConstraints (callback)
			* solveMultiBodyGroup (btMultiBodyConstraintSolver)
				* solveGroup 求解器三步曲

## 非刚体
btSoftRigidDynamicsWorld (btDynamicsWorld -> btDiscreteDynamicsWorld -> btSoftRigidDynamicsWorld)

* btDeformableBodySolver  
	* predictMotion

# Physx 中 碰撞检测
## demo  
PhysXSample 

## broadphase  
SAT & MBP (multi-box pruning)

* Scene
	* broadPhase
		* updateAABBsAndBP (AABBManager)
			* finalizeUpdate
				* update (BroadPhase，为 BroadPhaseSap 或 BroadPhaseMBP 或 BroadPhaseABP)

* PxScene > NpSceneAccessor > NpSceneQueries > NpScene
	* simulateOrCollide 
		* updateDirtyShaders
			* updateConstants (NpConstraint)

NpScene.executeScene
	simulate (ScbScene -> ScScene)
		stepSetupCollide

* setupSolverConstraint (ConstraintHelper)
	* setSolverConstants

runInternal (DyDynamics)

PxSceneDesc 场景属性  
1. gravity 重力大小和方向，
2. PxSimulationEventCallback 模拟事件回调，
3. PxContactModifyCallback 碰撞解算修改回调，
4. PxCCDContactModifyCallback CCD的碰撞解算修改回调，
5. filterShader 全局的碰撞分类处理函数，
6. cpuDispatcher Cpu线程分配器

PxRigidDynamic

Kinematic型的rigidbody质量相当于无穷大，它基本不受力的影响，也基本不参与碰撞解算流程，它的运动是直接设定位置的，而非Kinematic型Rigidbody运动是通过速度，或者力进行计算的，而且碰到东西穿插了会进行复杂的碰撞解算。

Kinematic型由于不受力和碰撞的影响，所以比较适合随着动画运动的碰撞盒，或者由服务器同步运动的碰撞盒，中间不需要额外的计算干扰，比较省性能，也不会出现抖动。

弹簧常数kp和阻尼常数kd  

ERP = hkp/(hkp + kd)  

CFM = 1/(hkp + kd)  

其中h为步长。这些数值将产生与用隐式一阶积分模拟弹簧-阻尼系统相同的效果

# PhysX 中的求解器
接触约束和连接约束
```c++
enum ConstraintType
{
	eCONTACT_CONSTRAINT,	//!< Defines this pair is a contact constraint
	eJOINT_CONSTRAINT		//!< Defines this pair is a joint constraint
};
```
batch constraints对提供的constraints重新排序并生成 batchHeaders ，solver可以使用这些batchHeaders来加速约束求解(constraint solving)，方法是将独立约束组合在一起并使用 SIMD 寄存器中的多个通道并行求解。
## PhysX 中的PGS求解器
* PxsCreateFinalizeContactsTask.runInternal
	* createFinalizeContacts_Parallel 赋值SolverConstraintShaderPrepDesc
		* SetupSolverConstraint (DyConstraintSetup.cpp) 对每一个header.stride，求解约束；
			* DistanceJointSolverPrep 如果有约束，具体的约束赋值
			* SetupSolverConstraint 计算有效质量$ m_{i}^{eff} = 1 / (J_{i} M^{-1} J_{i}^{T}) = 1 / (J_{i}SS^{T}J_{i}^{T}) = 1 / (ZZ^{T}) = 1 / |Z|^2) $
其中$J_{i}$为由四个Vec3组成的广义速度 [lin0, ang0, lin1, ang1]。PhysX利用了$M^{-1}$的正定对称性，令$S=S^{T} = \sqrt{M^{-1}}$。其中unitResponse即为上述$|Z|^2$，存入s的ang0实为$S ang0$
				* preprocessRows
				* setSolverConstants 进一步计算一些迭代解用到的常量，包括软约束，其中velMultiplier对应$-m_{i}^{eff}$，constant对应$m_{i}^{eff} (b - Jv_{x})$
		* createFinalizeSolverContacts 碰撞接触约束
			* setupFinalizeSolverConstraints
				* constructContactConstraint 计算法线方向上相关参数，其中velMultiplier对应$1/K$，penetrationInvDtPt8对应$v = 0.8D_p / \Delta t$，$D_p$是穿透深度，有穿透时小于0，使得相互穿插而无初速度的物体可以弹出来。

```c++
//DyContactPrepShared.h/constructContactConstraint

FloatV scaledBias = FMul(velMultiplier, penetrationInvDtPt8);

const BoolV isGreater2 = BAnd(BAnd(FIsGrtr(restitution, zero), FIsGrtr(bounceThreshold, vrel)), FIsGrtr(FNeg(vrel), penetrationInvDt));

const BoolV ccdSeparationCondition = FIsGrtrOrEq(ccdMaxSeparation, penetration);

scaledBias = FSel(BAnd(ccdSeparationCondition, isGreater2), zero, scaledBias);

const FloatV sumVRel(vrel);

FloatV targetVelocity = FAdd(cTargetVel, FSel(isGreater2, FMul(FNeg(sumVRel), restitution), zero));

//Note - we add on the initial target velocity
targetVelocity = FSub(targetVelocity, vrel);

const FloatV biasedErr = FScaleAdd(targetVelocity, velMultiplier, FNeg(scaledBias));
const FloatV unbiasedErr = FScaleAdd(targetVelocity, velMultiplier, FSel(isGreater2, zero, FNeg(FMax(scaledBias, zero))));
```
>* isGreater2：只有当恢复系数大于0、碰撞的前的速度大小大于一个bounceThreshold的阈值、且速度大小还大于$D_p / \Delta t$时，才将这次碰撞中的目标速度中考虑反弹速度的贡献。isGreater2为true时一般是高速碰撞，为false是低速接触。低速接触的解算目标是为了让物体能停在接触面上。
>* ccdSeparationCondition：给Speculative CCD 使用的参数，默认为PX_MAX_F32。
>* scaledBias：Baumgarte stabilization的速度乘以  ，这项在高速碰撞下一般为0。
>* cTargetVel：如果用户在碰撞修改(ContactModify)中设置了目标速度则会取到非零值，默认是0。
>* targetVelocity不是$v_{k+1}$而是$v_{k}$。这里targetVelocity =FSub(targetVelocity, vrel) 是为了让解算的时候速度初值都是0，而非碰撞时的世界空间的值。
>* biasedErr和unbiasedErr：
高速碰撞时两者相同，对应于$ v / K $
低速碰撞时:biasedErr等于$(v - 0.8D_p / \Delta t) / K$; unbiasedErr在无穿透时($D_p > 0$)等于$(v - 0.8D_p / \Delta t) / K$,有穿透时为$ v / K $。
区分biasedErr和unbiasedErr是因为PhysX在动力学解算中是不改变刚体位置的。迭代整体被分为了先位置迭代（默认4次）再速度迭代（默认1次），而位置迭代的解算中只会用到biasedErr，速度迭代只会用到unbiasedErr。位置迭代完了的速度会用来计算刚体的位置、角度，而随后的速度迭代完了得到的速度是刚体在模拟结束后该时刻的速度。其实也就是把平均速度和瞬时速度分开了。这么做的目的是为了让Baumgarte stablization引入的修正量在速度迭代中被略去，以保证不引入能量增益。

```c++
//DyContactPrep.cpp/setupFinalizeSolverConstraints

const FloatV velMultiplier = FSel(FIsGrtr(resp, zero), FDiv(p8, resp), zero);

FloatV targetVel = V3Dot(tvel, t0);

const FloatV vrel1 = FAdd(V3Dot(t0, linVel0), V3Dot(raXn, angVel0));
const FloatV vrel2 = FAdd(V3Dot(t0, linVel1), V3Dot(rbXn, angVel1));
const FloatV vrel = FSub(vrel1, vrel2);

targetVel = FSub(targetVel, vrel);

f0->normalXYZ_appliedForceW = V4SetW(t0, zero);
f0->raXnXYZ_velMultiplierW = V4SetW(raXnSqrtInertia, velMultiplier);
f0->rbXnXYZ_biasW = V4SetW(rbXnSqrtInertia, FMul(V3Dot(t0, error), invDt));
FStore(targetVel, &f0->targetVel);
```
>* velMultiplier：$0.8/K$;
>* tvel：如果用户在碰撞修改(ContactModify)中设置了目标速度则会取到非零值，默认是0。
>* error：两个刚体上碰撞点（Anchor）之间的向量，从1指向0。因为物理模拟是离散的，碰撞检测并不是两个刚体之间刚好接触才产生碰撞约束。
>* biasW：切线方向的Baumgarte stabilization。
>* raXnXYZ：$S (r \times \xi)$  。

* PxsSolverSetupSolveTask.runInternal
	* SolverCoreGeneral.solveV_Blocks
		* SolveBlockParallel
			* solve1DBlock
				* solve1D (DySolverConstraints.cpp) SI,一维约束迭代。$\lambda_{k+1} = m_{i}^{eff} (b - J v_{k}) + \lambda_{k}$。其中unclampedForce对应$\lambda_{k+1}$，appliedForce对应$\lambda_{k}$，normalVel对应$J v_{k}$，vMul对应$-m_{i}^{eff}$，新增冲量$\Delta \lambda = \lambda_{k + 1} - \lambda_{k}$用于更新刚体速度。angState为$\sqrt{M} \omega$，即$\sqrt{M} \omega_{k + 1} = 1 / \sqrt{M} F^{k} + \sqrt{M} \omega_{k}$。invInertiaScale是一个标量，是PhysX为修改特定的约束表现留的一个量，用它缩放物体对特定约束的质量/惯量表现。
			* solve1DConcludeBlock
				* conclude1D
			* solve1DBlockWriteBack
			* solveContactBlock 碰撞求解
				* solveContact 计算摩擦
					* solveDynamicContacts 计算物体与动态物体的碰撞
			* solveContact_BStaticBlock 碰撞求解，计算物体与静态物体的碰撞

* updatePostKinematic.runInternal
	* DynamicsContext.updatePostKinematic
		* createSolverTaskChain
			* PxsSolverSetupSolveTask

```c++
//DySolverConstraintsShared.h/solveDynamicContacts

//KS - clamp the maximum force
const FloatV _deltaF = FMax(FNegScaleSub(normalVel, velMultiplier, biasedErr), FNeg(appliedForce));
const FloatV _newForce = FAdd(appliedForce, _deltaF);
const FloatV newForce = FMin(_newForce, maxImpulse);
const FloatV deltaF = FSub(newForce, appliedForce);
```
第一行是为了保证_deltaF与appliedForce的和总是大于等于0的，即保证了法线方向的总冲量不会有负值。后面三行计算出截断后真正的deltaF。

```c++
// DySolverConstraints.cpp/solveContact 

// appliedForce -bias * velMultiplier - a hoisted part of the total impulse computation
const FloatV tmp1 = FNegScaleSub(FSub(bias, targetVel),velMultiplier,appliedForce);				

// Algorithm:
// if abs(appliedForce + deltaF) > maxFrictionImpulse
//    clamp newAppliedForce + deltaF to [-maxDynFrictionImpulse, maxDynFrictionImpulse]
//      (i.e. clamp deltaF to [-maxDynFrictionImpulse-appliedForce, maxDynFrictionImpulse-appliedForce]
//    set broken flag to true || broken flag

// FloatV deltaF = FMul(FAdd(bias, normalVel), minusVelMultiplier);
// FloatV potentialSumF = FAdd(appliedForce, deltaF);

const FloatV totalImpulse = FNegScaleSub(normalVel, velMultiplier, tmp1);

// On XBox this clamping code uses the vector simple pipe rather than vector float,
// which eliminates a lot of stall cycles

const BoolV clamp = FIsGrtr(FAbs(totalImpulse), maxFrictionImpulse);

const FloatV totalClamped = FMin(maxDynFrictionImpulse, FMax(negMaxDynFrictionImpulse, totalImpulse));

const FloatV newAppliedForce = FSel(clamp, totalClamped,totalImpulse);

broken = BOr(broken, clamp);

FloatV deltaF = FSub(newAppliedForce, appliedForce);
```
计算截断的时候要先与静摩擦的最大冲量比，如果比静摩擦的大才截断到动摩擦的。

solver iteration计数默认为 4 次位置迭代和 1 次速度迭代。
Solver将contacts分组为friction patches;friction patches是一组contacts，它们共享相同的材料并具有相似的contact normals。但是，Solver允许每个contact manager(一对Shape)最多有 32 个friction patches。如果产生超过 32 个friction patches(这可能是由于非常复杂的碰撞几何Shape或非常大的contact offsets)，Solver将忽略剩余的friction patches。发生这种情况时，checked/debug版本中将出现警告。

## Task
UpdateContinuationTask.runInternal
	updatePostKinematic
		createSolverTaskChain
			PxsSolverCreateFinalizeConstraintsTask
			PxsSolverSetupSolveTask

## PGS vs TGS (Projected/Temporal Gauss-Seidel Solver)

## PhysX的LCP求解器
* onSubstep
	* updateVehicleManager
		* updateAndRecordTelemetryData (SampleVehicle_VehicleManager)
			* PxVehicleUpdateSingleVehicleAndStoreTelemetryData
				* updateSingleVehicleAndStoreTelemetryData
					* update
						* updateDriveNW
							* solveDriveNWInternalDynamicsEnginePlusDrivenWheels
								* MatrixNGaussSeidelSolver.solve 使用LDL-GS求解Ax=b
								* MatrixNNLUSolver 使用LU分解求解Ax=b

# PhysX 其它笔记
PxFrictionType 摩擦求解模型
# reference
[Video Game Physics Tutorial](https://www.toptal.com/game/video-game-physics-part-i-an-introduction-to-rigid-body-dynamics)

[bullet3](https://github.com/bulletphysics/bullet3/releases)

[PhysX](https://github.com/NVIDIAGameWorks/PhysX)

[PhysX doc](https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/Introduction.html)

[Game Physics Series](http://allenchou.net/game-physics-series/)

# 附录  
## URDF文件
[Unified Robot Description Format](http://wiki.ros.org/urdf/Tutorials) (URDF，标准化机器人描述格式) 

